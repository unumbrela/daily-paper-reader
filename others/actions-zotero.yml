type: ActionsTagsBackup
author: zwwen0711
platformVersion: 7.0.30
pluginVersion: 2.2.4
timestamp: '2025-12-28T17:22:32.173Z'
actions:
  1766933168242-lENQeb2s:
    event: 1
    operation: 4
    data: >-
      const MARKER_SUMMARY = "ã€ğŸ¤– AI Summaryã€‘";
      const MARKER_CHAT = "ã€ğŸ’¬ Chat Historyã€‘";
      const MARKER_ORIG = "ã€ğŸ“„ Original Abstractã€‘";
      const BR_PLACEHOLDER = /__BR__/g;
      const AUTO_NOTE_TAG = "dpr-ai-summary-note";
      const RETRY_DELAYS = [300, 800, 1500];

      const targetItems = (typeof items !== "undefined" && items && items.length > 0)
        ? items
        : ((typeof item !== "undefined" && item) ? [item] : []);

      if (!targetItems || targetItems.length === 0) {
        return "âŒ é”™è¯¯ï¼šæœªæ¥æ”¶åˆ°æœ‰æ•ˆæ¡ç›®ï¼ˆè¯·å…ˆåœ¨æ¡ç›®ä¸Šè§¦å‘è„šæœ¬ï¼‰";
      }

      function normalizeText(v) {
        return (v || "").toString();
      }

      function normalizeSourceText(v) {
        const plain = normalizeText(v)
          .replace(/<br\s*\/?>/gi, "\n")
          .replace(/<\/p>/gi, "\n")
          .replace(/<p[^>]*>/gi, "")
          .replace(/<[^>]+>/g, "")
          .replace(BR_PLACEHOLDER, "\n")
          .replace(/\r/g, "\n");
        return plain
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }

      function hasAnyMarker(text) {
        return (
          text.includes(MARKER_SUMMARY) ||
          text.includes(MARKER_CHAT) ||
          text.includes(MARKER_ORIG)
        );
      }

      function cleanForCompare(v) {
        return normalizeSourceText(v).replace(/\s+/g, "");
      }

      function normalizeSectionFingerprint(value) {
        return normalizeSourceText(value)
          .toLowerCase()
          .replace(/\s+/g, "")
          .replace(/[`*_#>\-+]/g, "")
          .replace(/^\*\*?(.+?)\*\*?:?/g, "")
          .replace(/\*\*/g, "")
          .replace(/[^\w\u4e00-\u9fa5]/g, "");
      }

      function normalizeTitleKey(title) {
        return normalizeSourceText(title)
          .toLowerCase()
          .replace(/\s+/g, "")
          .replace(/[^\w\u4e00-\u9fa5]/g, "");
      }

      function escapeHtml(v) {
        return normalizeText(v)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function getFieldSafe(targetItem, fieldName) {
        try {
          return normalizeText(targetItem.getField(fieldName));
        } catch (err) {
          return "";
        }
      }

      function getSourceText(targetItem) {
        const candidateFields = [
          "citation_abstract",
          "dc.description",
          "DC.description",
          "description",
          "abstract",
          "abstractNote",
          "extra",
        ];
        let bestText = "";
        let bestLength = 0;
        for (const fieldName of candidateFields) {
          const raw = normalizeSourceText(getFieldSafe(targetItem, fieldName));
          if (!raw) {
            continue;
          }

          if (hasAnyMarker(raw)) {
            return raw;
          }

          if (raw.length > bestLength) {
            bestText = raw;
            bestLength = raw.length;
          }
        }
        return bestText;
      }

      function getMarkerTitle(lineText) {
        const text = normalizeText(lineText).trim();
        if (!text) return "";
        const markerText = [MARKER_SUMMARY, MARKER_CHAT, MARKER_ORIG].map((v) =>
          normalizeText(v).trim(),
        );
        const map = {
          [markerText[0]]: "ğŸ¤– AI Summary",
          [markerText[1]]: "ğŸ’¬ Chat History",
          [markerText[2]]: "ğŸ“„ Original Abstract",
        };
        for (const marker of markerText) {
          if (text.startsWith(marker)) {
            return map[marker] || text;
          }
        }
        return "";
      }

      function trimLeadingMetadataLines(text) {
        const lines = normalizeSourceText(text).split("\n");
        const filtered = [];
        let started = false;
        for (const line of lines) {
          const t = line.trim();
          if (!t) {
            if (!started) {
              continue;
            }
          }
          if (!started && t.startsWith("Tags:")) {
            continue;
          }
          if (!started && /^> ç”± daily-paper-reader è‡ªåŠ¨ç”Ÿæˆ/i.test(t)) {
            continue;
          }
          if (!started && t.includes("daily-paper-reader è‡ªåŠ¨ç”Ÿæˆ")) {
            continue;
          }
          started = true;
          filtered.push(t);
        }
        return filtered
          .join("\n")
          .replace(/\n{3,}/g, "\n\n")
          .trim();
      }

      function normalizeSectionTitle(line) {
        const text = normalizeText(line).trim();
        const markerTitle = getMarkerTitle(text);
        if (markerTitle) return markerTitle;
        return text
          .replace(/^#{1,6}\s*/, "")
          .replace(/^[ğŸ¤–ğŸ’¬ğŸ“„]\s*/, "")
          .replace(/^\*\s*/, "")
          .trim();
      }

      function isSectionHeading(line) {
        const text = normalizeText(line).trim();
        if (!text) {
          return false;
        }
        if (getMarkerTitle(text)) {
          return true;
        }
        if (/^#{1,6}\s+/.test(text)) {
          return true;
        }
        return (
          /^[ğŸ¤–ğŸ’¬ğŸ“„]/.test(text) ||
          /^(AI Summary|Chat History|Original Abstract|è®ºæ–‡è¯¦ç»†æ€»ç»“|åŸå§‹æ‘˜è¦|æ ‡é¢˜|æ‘˜è¦|èŠå¤©è®°å½•)/i.test(
            text,
          )
        );
      }

      function splitSectionsByHeadings(fullText) {
        const lines = normalizeSourceText(fullText).split("\n");
        const result = [];
        let currentTitle = "ğŸ“ æ–‡ç« å†…å®¹";
        let currentBuffer = [];

        const flush = () => {
          const content = trimLeadingMetadataLines(currentBuffer.join("\n"));
          if (content) {
            result.push({
              title: currentTitle,
              content,
            });
          }
          currentBuffer = [];
        };

        for (const rawLine of lines) {
          const headingTitle = normalizeSectionTitle(rawLine);
          if (isSectionHeading(rawLine)) {
            flush();
            currentTitle = headingTitle ? headingTitle : currentTitle;
            if (!currentTitle) {
              currentTitle = "ğŸ“ æ–‡ç« å†…å®¹";
            }
            continue;
          }
          currentBuffer.push(rawLine);
        }
        flush();

        return result;
      }

      function splitSectionsByMarkers(fullText) {
        const cleaned = normalizeSourceText(fullText);
        const marks = [
          { marker: MARKER_SUMMARY, title: "ğŸ¤– AI Summary" },
          { marker: MARKER_CHAT, title: "ğŸ’¬ Chat History" },
          { marker: MARKER_ORIG, title: "ğŸ“„ Original Abstract" },
        ];
        const matched = marks
          .map((m) => ({
            marker: m.marker,
            title: m.title,
            index: cleaned.indexOf(m.marker),
          }))
          .filter((item) => item.index > -1)
          .sort((a, b) => a.index - b.index);

        if (!matched.length) {
          return [];
        }

        const result = [];
        for (let i = 0; i < matched.length; i += 1) {
          const current = matched[i];
          const nextIndex =
            i + 1 < matched.length ? matched[i + 1].index : cleaned.length;
          const rawSection = cleaned.substring(
            current.index + current.marker.length,
            nextIndex,
          );
          const content = trimLeadingMetadataLines(rawSection);
          if (!content) {
            continue;
          }
          result.push({ title: current.title, content });
          if (i === 0 && current.index > 0) {
            const prefix = trimLeadingMetadataLines(cleaned.substring(0, current.index));
            if (prefix) {
              result.unshift({ title: "ğŸ“ æ–‡ç« å†…å®¹", content: prefix });
            }
          }
        }
        return result;
      }

      function dedupeSections(sections) {
        const output = [];
        const seenTitles = {};
        const seenContents = new Set();
        const titleContentMap = {};

        for (const section of sections) {
          const title = normalizeText(section.title || "ğŸ“ æ–‡ç« å†…å®¹").trim();
          const content = trimLeadingMetadataLines(section.content || "");
          if (!content) {
            continue;
          }

          const c = normalizeSectionFingerprint(content);
          const t = normalizeTitleKey(title);
          const titleCount = seenTitles[t] || 0;
          seenTitles[t] = titleCount + 1;
          titleContentMap[t] = titleContentMap[t] || new Set();

          if (seenContents.has(c)) {
            continue;
          }

          if (titleContentMap[t].has(c)) {
            continue;
          }
          titleContentMap[t].add(c);
          seenContents.add(c);
          output.push({
            title,
            content,
          });
        }
        return output;
      }

      function splitSections(fullText) {
        const cleaned = normalizeSourceText(fullText);
        if (!cleaned) {
          return {
            valid: false,
            reason: "âš ï¸ æ¡ç›®æ‘˜è¦ä¸ºç©ºï¼Œç­‰å¾…é‡è¯•ä¸­ã€‚",
          };
        }

        const markerSections = splitSectionsByMarkers(cleaned);
        const headingSections = splitSectionsByHeadings(cleaned);
        const sections = dedupeSections(markerSections.concat(headingSections));

        if (!sections.length) {
          return {
            valid: true,
            sections: [{ title: "ğŸ“ æ–‡ç« å†…å®¹", content: cleaned }],
          };
        }

        return {
          valid: true,
          sections,
        };
      }

      function collectItemMetadata(targetItem) {
        const creators = targetItem.getCreators ? targetItem.getCreators() : [];
        const authorTexts = creators
          .map((author) => {
            const part =
              normalizeText(author.lastName) ||
              normalizeText(author.name) ||
              normalizeText(author.fieldMode) ||
              "";
            const display = normalizeText(author.firstName)
              ? `${part} ${normalizeText(author.firstName)}`
              : part;
            return display.trim();
          })
          .filter(Boolean);

        const tags = targetItem.getTags ? targetItem.getTags() : [];
        const tagTexts = tags
          .map((t) => normalizeText(t.tag).trim())
          .filter(Boolean);

        const metadataItems = [
          ["æ ‡é¢˜", normalizeText(targetItem.getField("title"))],
          ["ä½œè€…", authorTexts.join("ï¼›")],
          ["å‘è¡¨å¹´ä»½", normalizeText(targetItem.getField("year"))],
          ["æ—¥æœŸ", normalizeText(targetItem.getField("date"))],
          ["æœŸåˆŠ", normalizeText(targetItem.getField("publicationTitle"))],
          ["å‡ºç‰ˆç¤¾", normalizeText(targetItem.getField("publisher"))],
          ["DOI", normalizeText(targetItem.getField("DOI"))],
          ["æ–‡ç« ç±»å‹", normalizeText(targetItem.getField("itemType"))],
          ["URL", normalizeText(targetItem.getField("url"))],
          ["æ ‡ç­¾", tagTexts.join("ï¼›")],
        ].filter((tuple) => tuple[1]);

        if (!metadataItems.length && !authorTexts.length && !tagTexts.length) {
          return "";
        }

        const lines = ["## ğŸ“Œ æ–‡ç« å…ƒä¿¡æ¯"];
        metadataItems.forEach(([k, v]) => {
          lines.push(`- **${k}**: ${normalizeText(v)}`);
        });
        return lines.join("\n");
      }

      function formatChatMarkdown(rawChatString) {
        if (!rawChatString) {
          return "";
        }
        const segments = rawChatString.split(/(?=ğŸ‘¤ User:|ğŸ¤– AI:)/g);
        const lines = [];
        for (const seg of segments) {
          const cleanText = normalizeSourceText(seg).trim();
          if (!cleanText) {
            continue;
          }
          if (cleanText.startsWith("ğŸ‘¤ User:")) {
            lines.push(`**ğŸ‘¤ User:**\n${cleanText.replace("ğŸ‘¤ User:", "").trim()}`);
          } else if (cleanText.startsWith("ğŸ¤– AI:")) {
            lines.push(`**ğŸ¤– AI:**\n${cleanText.replace("ğŸ¤– AI:", "").trim()}`);
          }
        }
        return lines.join("\n\n");
      }

      function buildNoteMarkdown(targetItem, parsed) {
        const blocks = [];
        const rawText = parsed && parsed.rawText ? normalizeSourceText(parsed.rawText) : "";
        const addBlock = (title, content) => {
          if (!content) return;
          blocks.push(`## ${title}`);
          blocks.push(content);
        };

        const stripLeadingHeading = (text, title) => {
          const escaped = title.replace(
            /[.*+?^${}()|[\]\\]/g,
            "\\$&",
          );
          return text
            .replace(
              new RegExp(`^\\s*#{1,6}\\s*${escaped}\\s*\\n+`, "i"),
              "",
            )
            .trim();
        };

        const metadata = collectItemMetadata(targetItem);
        if (metadata) {
          addBlock("ğŸ“‹ æ–‡ç« å…ƒä¿¡æ¯", metadata);
        }

        const sections = parsed.sections || [];
        const hasChat = sections.some((item) => /chat history|ğŸ’¬/i.test(item.title));
        sections.forEach((section) => {
          const title = normalizeText(section.title || "ğŸ“ æ–‡ç« å†…å®¹");
          let content = trimLeadingMetadataLines(section.content);
          if (!content) {
            return;
          }

          if (/chat history|ğŸ’¬/i.test(title)) {
            content = formatChatMarkdown(content) || content;
          }
          addBlock(title, content);
        });

        if (!sections.length) {
          addBlock("ğŸ“ æ–‡ç« å†…å®¹", "ï¼ˆæ— å¯è§£æå†…å®¹ï¼‰");
        }

        if (!hasChat && rawText && rawText.includes("ğŸ’¬ Chat History")) {
          const markerStart = normalizeSourceText(parsed.rawText).indexOf(MARKER_CHAT);
          if (markerStart > -1) {
            const markerChat = normalizeSourceText(parsed.rawText).substring(
              markerStart + MARKER_CHAT.length,
            );
            addBlock("ğŸ’¬ Chat History", formatChatMarkdown(markerChat));
          }
        }

        return blocks.join("\n\n");
      }

      function markdownToPlainHtml(markdownText) {
        const lines = normalizeText(markdownText).split(/\n/);
        const htmlParts = [];
        let paragraphBuffer = [];
        const flushParagraph = () => {
          if (!paragraphBuffer.length) {
            return;
          }
          const blockText = paragraphBuffer.join("\n").trim();
          if (!blockText) {
            paragraphBuffer = [];
            return;
          }
          const headingMatch = blockText.match(/^(#{1,6})\s+(.*)$/);
          if (headingMatch) {
            const level = Math.min(6, headingMatch[1].length);
            htmlParts.push(
              `<h${level} style=\"margin: 14px 0 8px 0; color:#0277bd; border-bottom:1px solid #e3f2fd;\">${escapeHtml(
                headingMatch[2],
              )}</h${level}>`,
            );
          } else if (/^\s*>\s*/.test(blockText)) {
            htmlParts.push(
              `<blockquote style=\"margin: 12px 0; padding-left: 12px; color:#666; border-left: 3px solid #bbdefb; white-space: pre-wrap;\">${escapeHtml(
                blockText.replace(/^\s*>\s*/, ""),
              ).replace(/\n/g, "<br>")}</blockquote>`,
            );
          } else {
            const esc = escapeHtml(blockText).replace(/\n/g, "<br>");
            htmlParts.push(
              `<p style=\"display:block; color: #333; font-size: 1em; line-height: 1.6; white-space: pre-wrap; margin: 0 0 12px 0;\">${esc}</p>`,
            );
          }
          paragraphBuffer = [];
        };

        for (const line of lines) {
          if (!line.trim()) {
            flushParagraph();
            continue;
          }
          paragraphBuffer.push(line);
        }
        flushParagraph();

        return `<div style="font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: #333; line-height: 1.6;">${htmlParts
          .filter(Boolean)
          .join("")}</div>`;
      }

      function hasAutoSummaryNote(targetItem) {
        try {
          const notes = Zotero.Items.get(targetItem.getNotes()) || [];
          return notes.some((note) => {
            const tags = note.getTags ? note.getTags() : [];
            if (tags?.some((tagItem) => tagItem.tag === AUTO_NOTE_TAG)) {
              return true;
            }
            const title = normalizeText(note.getNoteTitle ? note.getNoteTitle() : "")
              .toLowerCase();
            if (title.includes("ai summary") || title.includes("daily-paper")) {
              return true;
            }
            const noteHtml = normalizeText(note.getNote()).toLowerCase();
            return (
              noteHtml.includes("ğŸ¤– ai summary") ||
              noteHtml.includes("ğŸ“„ original abstract") ||
              noteHtml.includes("dpr-ai-summary-note")
            );
          });
        } catch (err) {
          return false;
        }
      }

      async function removeAutoSummaryNotes(targetItem) {
        try {
          const notes = Zotero.Items.get(targetItem.getNotes()) || [];
          for (const note of notes) {
            const tags = note.getTags ? note.getTags() : [];
            const hasTag = tags?.some((tagItem) => tagItem.tag === AUTO_NOTE_TAG);
            if (!hasTag) {
              const title = normalizeText(note.getNoteTitle ? note.getNoteTitle() : "")
                .toLowerCase();
              const noteHtml = normalizeText(note.getNote()).toLowerCase();
              const isAuto =
                title.includes("ai summary") ||
                title.includes("daily-paper") ||
                noteHtml.includes("ğŸ¤– ai summary") ||
                noteHtml.includes("ğŸ“„ original abstract");
              if (!isAuto) {
                continue;
              }
            }

            try {
              if (note.eraseTx) {
                await note.eraseTx();
              } else if (note.deleteTx) {
                await note.deleteTx();
              }
            } catch (err) {
              // ignore removal failure
            }
          }
        } catch (err) {
          // ignore removal process
        }
      }

      async function processItem(targetItem) {
        const title = normalizeText(targetItem.getField("title")) || "[æ— æ ‡é¢˜]";

        if (hasAutoSummaryNote(targetItem)) {
          await removeAutoSummaryNotes(targetItem);
        }

        let sourceText = "";
        for (let i = 0; i <= RETRY_DELAYS.length; i += 1) {
          sourceText = getSourceText(targetItem);
          if (sourceText) {
            break;
          }
          if (triggerType === "createItem" && i < RETRY_DELAYS.length) {
            await sleep(RETRY_DELAYS[i]);
          }
        }

        if (!sourceText) {
          return `âš ï¸ [${escapeHtml(title)}] æš‚æœªè¯»åˆ°æ‘˜è¦ï¼Œå¯¼å…¥å¤±è´¥`;
        }

        const parsed = splitSections(sourceText);
        if (!parsed.valid) {
          return parsed.reason;
        }

        const noteMarkdown = buildNoteMarkdown(targetItem, {
          ...parsed,
          rawText: sourceText,
        });
        let noteHtml = "";
        const canUseBetterNotes =
          !!(
            Zotero.BetterNotes &&
            Zotero.BetterNotes.api &&
            Zotero.BetterNotes.api.convert &&
            Zotero.BetterNotes.api.convert.md2html &&
            Zotero.BetterNotes.api.note &&
            Zotero.BetterNotes.api.note.insert
          );

        if (canUseBetterNotes) {
          try {
            noteHtml = await Zotero.BetterNotes.api.convert.md2html(noteMarkdown);
          } catch (err) {
            noteHtml = markdownToPlainHtml(noteMarkdown);
          }
        } else {
          noteHtml = markdownToPlainHtml(noteMarkdown);
        }

        const newNote = new Zotero.Item("note");
        newNote.libraryID = targetItem.libraryID;
        newNote.parentID = targetItem.id;
        newNote.addTag(AUTO_NOTE_TAG, 1);
        newNote.setNote(noteHtml);
        await newNote.saveTx();

        return `âœ… [${escapeHtml(title)}] å·²è‡ªåŠ¨åˆ›å»º AI Summary æ¡ç›®ç¬”è®°`;
      }

      const results = [];
      for (let i = 0; i < targetItems.length; i += 1) {
        results.push(await processItem(targetItems[i]));
      }

      return results.join("\n");
    shortcut: ''
    enabled: true
    menu: ''
    name: Process AI Summary
    showInMenu:
      item: false
      collection: false
      tools: false
      reader: false
      readerAnnotation: false
