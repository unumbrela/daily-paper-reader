<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  <title>Daily Paper Reader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="citation_journal_title" content="Daily Paper Reader (ArXiv)">
  <meta name="citation_title" content="Daily Paper Reader Default Entry">
  <meta name="citation_author" content="Daily Paper Reader Team">
  <meta name="citation_author" content="Docsify Renderer">
  <meta name="citation_date" content="2024/01/01">
  <meta name="citation_pdf_url" content="https://daily-paper-reader.invalid/default.pdf">
  <meta name="citation_volume" content="1">
  <meta name="citation_issue" content="1">
  <meta name="citation_firstpage" content="100">
  <meta name="citation_lastpage" content="110">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css">
  <!-- KaTeX ç”¨äºå…¬å¼æ¸²æŸ“ -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  
  <style>
    :root {
      --sidebar-width: 260px;
      --sidebar-min-width: 180px;
      --sidebar-max-width: 480px;
    }

    .katex .katex-mathml {
        display: none !important;
    }
    /* è¯„è®ºåŒºå®¹å™¨ï¼šæœ€å°é«˜åº¦ 200pxï¼Œéšå†…å®¹å¢é•¿ï¼Œæœ€å¤§é«˜åº¦ 660pxï¼Œè¶…å‡ºæ—¶å†…éƒ¨å†å²åŒºæ»šåŠ¨ */
    #paper-chat-container {
      margin-top: 50px;
      padding-top: 20px;
      border-top: 1px solid #eaecef;
      min-height: 200px;       /* å…¬å…±ç ”è®¨åŒºæœ€å°é«˜åº¦ */
      max-height: 660px;       /* å…¬å…±ç ”è®¨åŒºæœ€å¤§é«˜åº¦ */
      display: flex;
      flex-direction: column;  /* è®©å†å²åˆ—è¡¨å’Œè¾“å…¥åŒºæŒ‰åˆ—å¸ƒå±€ */
    }
    .chat-header { font-size: 1.5rem; font-weight: bold; margin-bottom: 20px; }
    
    /* æ¶ˆæ¯åˆ—è¡¨ï¼šå æ®è¯„è®ºåŒºé™¤è¾“å…¥åŒºå¤–çš„ç©ºé—´ï¼Œåªåœ¨å†…éƒ¨æ»šåŠ¨ */
    #chat-history {
      flex: 1 1 auto;
      min-height: 0;           /* é…åˆ flexï¼Œå…è®¸åœ¨å®¹å™¨å†…æ”¶ç¼© */
      overflow-y: auto;        /* åªåœ¨å†å²åŒºå†…éƒ¨æ»šåŠ¨ */
      background: #f9f9f9;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .msg-item { margin-bottom: 12px; }
    .msg-role { font-weight: bold; font-size: 0.9rem; }
    .msg-role.user { color: #42b983; } /* ç”¨æˆ·ç»¿è‰² */
    .msg-role.ai { color: #3b8eed; }   /* AI è“è‰² */
    .msg-content { margin-top: 4px; line-height: 1.6; color: #34495e; white-space: pre-wrap; }
    .msg-content sup { vertical-align: super; font-size: 0.75em; }
    /* å†å²è®°å½•ä¸­çš„æ€è€ƒè¿‡ç¨‹å®¹å™¨æ ·å¼ */
    .thinking-history-container {
      margin-top: 8px;
      border-left: 3px solid #ddd;
      padding-left: 8px;
      font-size: 0.85rem;
      color: #666;
    }
    .thinking-history-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .thinking-history-toggle {
      margin-left: 8px;
      font-size: 0.75rem;
      padding: 2px 6px;
      cursor: pointer;
    }
    .thinking-history-content.thinking-collapsed {
      max-height: 6em; /* çº¦ 3~4 è¡Œ */
      overflow: hidden;
    }
    .msg-time { font-size: 0.8rem; color: #999; margin-left: 10px; }

    /* è¾“å…¥åŒºåŸŸ */
    .input-area { display: flex; gap: 10px; }
    #user-input {
      flex: 1;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }
    #send-btn {
      padding: 0 20px;
      background: #42b983;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    #send-btn:disabled { background: #ccc; cursor: not-allowed; }

    /* è¦†ç›– Docsify ä¸»é¢˜é»˜è®¤çš„ä¸­é—´æ»šåŠ¨å®¹å™¨ï¼Œåªä¿ç•™æœ€å¤–å±‚é¡µé¢æ»šåŠ¨ */
    .content {
      height: auto !important;
      overflow: visible !important;
      margin-left: calc(var(--sidebar-width, 260px) + 15px) !important;
    }

    /* ä¾§è¾¹æ å®½åº¦å¯è°ƒ */
    .sidebar {
      width: var(--sidebar-width, 260px) !important;
      min-width: var(--sidebar-min-width, 180px);
      max-width: var(--sidebar-max-width, 480px);
    }

    /* ä¾§è¾¹æ æ‹–æ‹½å¥æŸ„ */
    #sidebar-resizer {
      position: fixed;
      top: 0;
      left: calc(var(--sidebar-width, 260px) - 2px);
      width: 4px;
      height: 100vh;
      cursor: col-resize;
      background: transparent;
      z-index: 999;
    }
    #sidebar-resizer::after {
      content: "";
      position: absolute;
      left: 1px;
      top: 0;
      bottom: 0;
      width: 0;
      background: transparent;
    }

    @media (max-width: 768px) {
      #sidebar-resizer {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="app">åŠ è½½ä¸­...</div>

  <script>
    window.$docsify = {
      name: 'Daily Paper Reader',
      repo: '',
      loadSidebar: true, // å¼€å¯ä¾§è¾¹æ 
      subMaxLevel: 2,
      
      // --- æ ¸å¿ƒï¼šæ³¨å†Œè‡ªå®šä¹‰æ’ä»¶ ---
      plugins: [
        function(hook, vm) {
          // ç¡®ä¿ marked å¼€å¯ GFM è¡¨æ ¼æ”¯æŒï¼Œå¹¶å…è®¸å†…è” HTMLï¼ˆç”¨äºèŠå¤©åŒº Markdown æ¸²æŸ“ï¼‰
          if (window.marked && window.marked.setOptions) {
            const baseOptions = (window.marked.getDefaults && window.marked.getDefaults()) || {};
            window.marked.setOptions(Object.assign({}, baseOptions, {
              gfm: true,
              breaks: false,
              tables: true,
              // å…è®¸ <sup> ç­‰å†…è” HTML ç›´æ¥æ¸²æŸ“ï¼Œè€Œä¸æ˜¯è¢«è½¬ä¹‰
              sanitize: false,
              mangle: false,
              headerIds: false,
            }));
          }

          // 1. è§£æå½“å‰æ–‡ç«  ID (ç®€å•ç”¨æ–‡ä»¶åä½œä¸º ID)
          const getPaperId = () => {
            return vm.route.file.replace('.md', ''); 
          };

          const metaFallbacks = {
            citation_title: 'Daily Paper Reader Default Entry',
            citation_journal_title: 'Daily Paper Reader (ArXiv)',
            citation_pdf_url: 'https://daily-paper-reader.invalid/default.pdf',
            citation_publication_date: '2024-01-01',
            citation_date: '2024/01/01'
          };

          const defaultAuthors = ['Daily Paper Reader Team', 'Docsify Renderer'];

          // å…¬å…±å·¥å…·ï¼šåœ¨æŒ‡å®šå…ƒç´ ä¸Šæ¸²æŸ“å…¬å¼
          const renderMathInEl = (el) => {
            if (!window.renderMathInElement || !el) return;
            window.renderMathInElement(el, {
              delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
              ],
              throwOnError: false,
            });
          };

          // å…¬å…±å·¥å…·ï¼šç®€å•è¡¨æ ¼ + æ ‡è®°ä¿®æ­£ï¼š
          // 1ï¼‰ç§»é™¤åè®®æ ‡è®° [ANS]/[THINK]
          // 2ï¼‰ç§»é™¤è¡¨æ ¼è¡Œä¹‹é—´å¤šä½™ç©ºè¡Œï¼Œé¿å…æŠŠåŒä¸€å¼ è¡¨æ‹†æˆä¸¤å—
          const normalizeTables = (markdown) => {
            if (!markdown) return '';
            // æ¸…ç†å†å²é—ç•™çš„åè®®æ ‡è®°
            let text = markdown.replace(/\[ANS\]/g, '').replace(/\[THINK\]/g, '');

            const lines = text.split('\n');
            const isTableLine = (line) => /^\s*\|.*\|\s*$/.test(line);
            const result = [];
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              const prev = result.length ? result[result.length - 1] : '';
              const next = i + 1 < lines.length ? lines[i + 1] : '';
              if (
                line.trim() === '' &&
                isTableLine(prev || '') &&
                isTableLine(next || '')
              ) {
                // è·³è¿‡è¡¨æ ¼è¡Œä¹‹é—´çš„ç©ºè¡Œ
                continue;
              }
              result.push(line);
            }
            return result.join('\n');
          };

          const escapeHtml = (str) => {
            return str
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;');
          };

          // è‡ªå®šä¹‰è¡¨æ ¼æ¸²æŸ“ï¼šæ£€æµ‹ Markdown è¡¨æ ¼å—å¹¶æ‰‹å†™ç”Ÿæˆ <table>ï¼Œ
          // å…¶ä»–å†…å®¹ä»äº¤ç»™ marked æ¸²æŸ“ã€‚
          const renderMarkdownWithTables = (markdown) => {
            const text = normalizeTables(markdown || '');
            const lines = text.split('\n');
            const isTableLine = (line) => /^\s*\|.*\|\s*$/.test(line);
            const isAlignLine = (line) => /^\s*\|(?:\s*:?-+:?\s*\|)+\s*$/.test(line);

            const parseRow = (line) => {
              const trimmed = line.trim().replace(/^\|/, '').replace(/\|$/, '');
              return trimmed.split('|').map((cell) => cell.trim());
            };

            const inlineRender = (cellText) => {
              if (!cellText) return '';
              if (window.marked && window.marked.parseInline) {
                return window.marked.parseInline(cellText);
              }
              return escapeHtml(cellText);
            };

            const blocks = [];
            let i = 0;

            const flushParagraph = (paraLines) => {
              const paraText = paraLines.join('\n').trim();
              if (!paraText) return;
              if (window.marked) {
                blocks.push(window.marked.parse(`\n${paraText}\n`));
              } else {
                blocks.push(`<p>${escapeHtml(paraText)}</p>`);
              }
            };

            while (i < lines.length) {
              const line = lines[i];

              // æ£€æµ‹è¡¨æ ¼å—ï¼šå½“å‰è¡Œæ˜¯è¡¨æ ¼è¡Œï¼Œä¸‹ä¸€è¡Œæ˜¯å¯¹é½è¡Œ
              if (isTableLine(line) && i + 1 < lines.length && isAlignLine(lines[i + 1])) {
                // å…ˆæŠŠå‰é¢çš„æ®µè½åˆ·æ‰
                // ï¼ˆé€šè¿‡ä¸æ–­æ”¶é›†éè¡¨æ ¼è¡Œå®ç°ï¼Œè¿™é‡Œå‡å®šæ²¡æœ‰å‰ç¼€æœªåˆ·æ®µè½ï¼‰

                const headerLine = lines[i];
                const alignLine = lines[i + 1]; // ç›®å‰æœªä½¿ç”¨ï¼Œä»…ç”¨æ¥æ£€æµ‹
                i += 2;

                const bodyLines = [];
                while (i < lines.length && isTableLine(lines[i])) {
                  bodyLines.push(lines[i]);
                  i++;
                }

                const headers = parseRow(headerLine);
                const rows = bodyLines.map(parseRow);

                let html = '<table class="chat-table"><thead><tr>';
                headers.forEach((h) => {
                  html += `<th>${inlineRender(h)}</th>`;
                });
                html += '</tr></thead><tbody>';
                rows.forEach((row) => {
                  html += '<tr>';
                  row.forEach((cell) => {
                    html += `<td>${inlineRender(cell)}</td>`;
                  });
                  html += '</tr>';
                });
                html += '</tbody></table>';

                blocks.push(html);
              } else {
                // éè¡¨æ ¼å—ï¼šæ”¶é›†åˆ°ä¸‹ä¸€ä¸ªè¡¨æ ¼æˆ–ç»“å°¾
                const paraLines = [];
                while (
                  i < lines.length &&
                  !(isTableLine(lines[i]) && i + 1 < lines.length && isAlignLine(lines[i + 1]))
                ) {
                  paraLines.push(lines[i]);
                  i++;
                }
                flushParagraph(paraLines);
              }
            }

            return blocks.join('');
          };

          const updateMetaTag = (name, content, options = {}) => {
            const old = document.querySelector(`meta[name="${name}"]`);
            if (old) old.remove();
            const useFallback = options.useFallback !== false;
            const value = content || (useFallback ? metaFallbacks[name] : '');
            if (!value) return;
            const meta = document.createElement('meta');
            meta.name = name;
            meta.content = value;
            document.head.appendChild(meta);
          };

          // 2. æ¸²æŸ“è¯„è®ºåŒºçš„ HTML ç»“æ„
          const renderChatUI = () => {
            return `
              <div id="paper-chat-container">
                <div class="chat-header">ğŸ’¬ å…¬å…±ç ”è®¨åŒº (Public Discussion)</div>
                <div id="chat-history">
                    <div style="text-align:center; color:#999">æ­£åœ¨åŠ è½½è®¨è®ºè®°å½•...</div>
                </div>
                <div class="input-area">
                  <textarea id="user-input" rows="3" placeholder="é’ˆå¯¹è¿™ç¯‡è®ºæ–‡æé—®ï¼Œæ‰€æœ‰äººå¯è§..."></textarea>
                  <button id="send-btn">å‘é€</button>
                </div>
              </div>
            `;
          };

          // 3. è·å–å†å²è®°å½• (API)
          const loadHistory = async (paperId) => {
            try {
              const res = await fetch(`/api/history?paper_id=${encodeURIComponent(paperId)}`);
              const data = await res.json();

              const historyDiv = document.getElementById('chat-history');
              if (!data || !data.length) {
                historyDiv.innerHTML = '<div style="text-align:center; color:#999">æš‚æ— è®¨è®ºï¼Œå¿«æ¥æŠ¢æ²™å‘ï¼</div>';
                return;
              }

              historyDiv.innerHTML = '';
              data.forEach(msg => {
                const item = document.createElement('div');
                item.className = 'msg-item';

                const header = document.createElement('div');
                const roleSpan = document.createElement('span');
                const isThinking = msg.role === 'thinking';
                const isAi = msg.role === 'ai' || isThinking;
                roleSpan.className = 'msg-role ' + (isAi ? 'ai' : 'user');
                roleSpan.textContent = isThinking
                  ? 'ğŸ§  AI æ€è€ƒè¿‡ç¨‹'
                  : (msg.role === 'ai' ? 'ğŸ¤– AI åŠ©æ‰‹' : 'ğŸ‘¤ å­¦æœ¯è·¯äºº');
                const timeSpan = document.createElement('span');
                timeSpan.className = 'msg-time';
                timeSpan.textContent = msg.time || '';
                header.appendChild(roleSpan);
                header.appendChild(timeSpan);

                if (!isThinking) {
                  const contentDiv = document.createElement('div');
                  contentDiv.className = 'msg-content';
                  const markdown = msg.content || '';
                  contentDiv.innerHTML = renderMarkdownWithTables(markdown);
                  renderMathInEl(contentDiv);

                  item.appendChild(header);
                  item.appendChild(contentDiv);
                  historyDiv.appendChild(item);
                  return;
                }

                // æ€è€ƒæ¶ˆæ¯ï¼šæ¸²æŸ“ä¸ºå¯æŠ˜å çš„å†å²æ€è€ƒåŒºåŸŸ
                const thinkingContainer = document.createElement('div');
                thinkingContainer.className = 'thinking-history-container';

                const thinkingHeader = document.createElement('div');
                thinkingHeader.className = 'thinking-history-header';
                const titleSpan = document.createElement('span');
                titleSpan.textContent = 'æ€è€ƒè¿‡ç¨‹';
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'thinking-history-toggle';
                toggleBtn.textContent = 'å±•å¼€';
                thinkingHeader.appendChild(titleSpan);
                thinkingHeader.appendChild(toggleBtn);

                const thinkingContent = document.createElement('div');
                thinkingContent.className = 'msg-content thinking-history-content thinking-collapsed';
                const markdown = msg.content || '';
                thinkingContent.innerHTML = renderMarkdownWithTables(markdown);
                renderMathInEl(thinkingContent);

                thinkingContainer.appendChild(thinkingHeader);
                thinkingContainer.appendChild(thinkingContent);

                // é»˜è®¤æŠ˜å ï¼Œç‚¹å‡»æŒ‰é’®å±•å¼€/æŠ˜å 
                toggleBtn.addEventListener('click', () => {
                  const collapsed = thinkingContent.classList.toggle('thinking-collapsed');
                  toggleBtn.textContent = collapsed ? 'å±•å¼€' : 'æŠ˜å ';
                });

                item.appendChild(header);
                item.appendChild(thinkingContainer);
                historyDiv.appendChild(item);
              });

              historyDiv.scrollTop = historyDiv.scrollHeight;

            } catch (e) {
              console.error("åŠ è½½å¤±è´¥", e);
            }
          };

          // 4. å‘é€æ¶ˆæ¯ (API)
          const sendMessage = async () => {
            const input = document.getElementById('user-input');
            const btn = document.getElementById('send-btn');
            const question = input.value.trim();
            const paperId = getPaperId();
            
            const paperContent = document.querySelector('.markdown-section').innerText; 

            if (!question) return;

            // UI é”å®š
            input.disabled = true;
            btn.disabled = true;
            btn.innerText = "æ€è€ƒä¸­...";
            
            // ä¹è§‚æ›´æ–°
            const historyDiv = document.getElementById('chat-history');
            historyDiv.innerHTML += `
                <div class="msg-item">
                    <div><span class="msg-role user">ğŸ‘¤ ä½ </span></div>
                    <div class="msg-content">${question}</div>
                </div>
            `;
            historyDiv.scrollTop = historyDiv.scrollHeight;

            // ä¸º AI åˆ›å»ºä¸€ä¸ªå ä½æ¶ˆæ¯ï¼ŒåŒ…å«â€œæ€è€ƒè¿‡ç¨‹ + å›ç­”å†…å®¹â€
            const aiItem = document.createElement('div');
            aiItem.className = 'msg-item';
            aiItem.innerHTML = `
                <div>
                  <span class="msg-role ai">ğŸ¤– AI åŠ©æ‰‹</span>
                </div>
                <div class="thinking-container" style="margin-top:8px; border-left:3px solid #ddd; padding-left:8px; font-size:0.85rem; color:#666; display:none;">
                  <div style="display:flex; align-items:center; justify-content:space-between;">
                    <span>æ€è€ƒè¿‡ç¨‹</span>
                    <button class="thinking-toggle" style="margin-left:8px; font-size:0.75rem; padding:2px 6px;">æŠ˜å </button>
                  </div>
                  <div class="thinking-content" style="white-space:pre-wrap; margin-top:4px;"></div>
                </div>
                <div class="msg-content"></div>
            `;
            historyDiv.appendChild(aiItem);

            const thinkingContainer = aiItem.querySelector('.thinking-container');
            const thinkingContent = aiItem.querySelector('.thinking-content');
            const toggleBtn = aiItem.querySelector('.thinking-toggle');
            const aiAnswerDiv = aiItem.querySelector('.msg-content');

            let thinkingBuffer = '';
            let answerBuffer = '';
            let thinkingCollapsed = false;
            let hasShownAnswer = false;
            let renderTimer = null;
            let streamBuffer = '';

            const applyThinkingCollapsedView = () => {
              if (!thinkingBuffer) return;
              const source = normalizeTables(thinkingBuffer);
              const maxLines = 3;
              let toRender = source;

              if (thinkingCollapsed) {
                const lines = source.split('\n');
                toRender = lines.slice(0, maxLines).join('\n') + (lines.length > maxLines ? '\n...' : '');
                toggleBtn.textContent = 'å±•å¼€';
              } else {
                toggleBtn.textContent = 'æŠ˜å ';
              }

              thinkingContent.innerHTML = renderMarkdownWithTables(toRender);
              renderMathInEl(thinkingContent);
            };

            const scheduleRender = () => {
              if (renderTimer) return;
              renderTimer = setTimeout(() => {
                renderTimer = null;

                // æ¸²æŸ“æ€è€ƒåŒº
                if (thinkingBuffer) {
                  thinkingContainer.style.display = 'block';
                  applyThinkingCollapsedView();
                }

                // æ¸²æŸ“æ­£å¼å›ç­”åŒº
                if (answerBuffer) {
                  const normalizedAnswer = normalizeTables(answerBuffer);
                  aiAnswerDiv.innerHTML = renderMarkdownWithTables(normalizedAnswer);
                  renderMathInEl(aiAnswerDiv);
                }
              }, 80);
            };

            toggleBtn.addEventListener('click', () => {
              thinkingCollapsed = !thinkingCollapsed;
              applyThinkingCollapsedView();
            });

            try {
              const res = await fetch('/api/chat_stream', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    paper_id: paperId,
                    question: question,
                    paper_content: paperContent 
                })
              });
              if (!res.body) {
                throw new Error('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæµå¼å“åº”è¯»å–');
              }

              const reader = res.body.getReader();
              const decoder = new TextDecoder('utf-8');

              while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const rawChunk = decoder.decode(value, { stream: true });

                // ä½¿ç”¨æŒ‰è¡Œ JSON åè®®è§£ææœåŠ¡ç«¯æ¨é€çš„æ•°æ®
                streamBuffer += rawChunk;
                const parts = streamBuffer.split('\n');
                streamBuffer = parts.pop() || '';

                for (const line of parts) {
                  const trimmed = line.trim();
                  if (!trimmed) continue;
                  let msg;
                  try {
                    msg = JSON.parse(trimmed);
                  } catch (e) {
                    console.error('è§£ææµå¼ JSON å¤±è´¥:', e, trimmed);
                    continue;
                  }

                  if (msg.type === 'thinking') {
                    thinkingBuffer += msg.content || '';
                    thinkingContainer.style.display = 'block';
                    // æ€è€ƒé˜¶æ®µé»˜è®¤å±•å¼€
                    thinkingCollapsed = false;
                    scheduleRender();
                  } else if (msg.type === 'answer') {
                    answerBuffer += msg.content || '';
                    scheduleRender();
                    // ä¸€æ—¦è¿›å…¥ç­”æ¡ˆé˜¶æ®µï¼Œè‹¥å­˜åœ¨æ€è€ƒå†…å®¹åˆ™æŠ˜å 
                    if (thinkingBuffer && !hasShownAnswer) {
                      hasShownAnswer = true;
                      thinkingCollapsed = true;
                      scheduleRender();
                    }
                  } else if (msg.type === 'error') {
                    answerBuffer += `\n[ERROR] ${msg.content || ''}`;
                    scheduleRender();
                  }
                }

                historyDiv.scrollTop = historyDiv.scrollHeight;
              }

              // æµç»“æŸåä¸å†ç«‹å³é‡è½½å†å²è®°å½•ï¼Œé¿å…è¦†ç›–å¸¦â€œæ€è€ƒè¿‡ç¨‹â€çš„å½“å‰æ¶ˆæ¯
              // å†å²è®°å½•ä¼šåœ¨é¡µé¢é‡æ–°æ‰“å¼€æ—¶é‡æ–°ä»åç«¯åŠ è½½
              input.value = '';
            } catch (e) {
              alert("å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•");
            } finally {
              input.disabled = false;
              btn.disabled = false;
              btn.innerText = "å‘é€";
              input.focus();
            }
          };

          // --- Docsify ç”Ÿå‘½å‘¨æœŸé’©å­ ---
          
          hook.doneEach(function() {
            // A. å¯¹æ­£æ–‡åŒºåŸŸè¿›è¡Œä¸€æ¬¡å…¨å±€å…¬å¼æ¸²æŸ“ï¼ˆæ”¯æŒ $...$ / $$...$$ï¼‰
            const mainContent = document.querySelector('.markdown-section');
            if (mainContent) {
              renderMathInEl(mainContent);

              // B. å°† Chat UI è¿½åŠ åˆ°æ–‡ç« åº•éƒ¨
              const div = document.createElement('div');
              div.innerHTML = renderChatUI();
              mainContent.appendChild(div);
            }

            // C. ç»‘å®šäº‹ä»¶
            const sendBtnEl = document.getElementById('send-btn');
            if (sendBtnEl) {
              sendBtnEl.addEventListener('click', sendMessage);
            }

            // è¾“å…¥æ¡†å›è½¦å‘é€ï¼ˆEnter å‘é€ã€Shift+Enter æ¢è¡Œï¼‰
            const inputEl = document.getElementById('user-input');
            if (inputEl) {
              inputEl.addEventListener('keydown', (e) => {
                // isComposing ç”¨äºé¿å…ä¸­æ–‡è¾“å…¥æ³•æ‹¼å†™è¿‡ç¨‹ä¸­è¯¯è§¦
                if (e.key === 'Enter' && !e.shiftKey && !e.isComposing) {
                  e.preventDefault();
                  sendMessage();
                }
              });
            }

            // D. åˆå§‹åŠ è½½æ•°æ®ï¼ˆä»…åœ¨é¡µé¢åŠ è½½æ—¶è¯·æ±‚ä¸€æ¬¡ï¼‰
            const paperId = getPaperId();
            loadHistory(paperId);

            // ----------------------------------------------------
            // E. ã€é‡ç‚¹ä¿®æ”¹ã€‘Zotero å…ƒæ•°æ®æ³¨å…¥é€»è¾‘ (å¸¦å»¶æ—¶å’Œå”¤é†’)
            // ----------------------------------------------------
            setTimeout(() => {
                try {
                  // 1. æŠ“å–æ ‡é¢˜ (ä¼˜å…ˆæŠ“ H1)
                  const titleEl = document.querySelector('.markdown-section h1');
                  const title = titleEl ? titleEl.innerText : document.title;

                  // 2. æŠ“å– PDF é“¾æ¥ (ä¼˜å…ˆæŠ“ ArXiv)
                  let pdfLinkEl = document.querySelector('a[href*="arxiv.org/pdf"]');
                  // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå†è¯•ç€æ‰¾ä»»ä½•ç»“å°¾æ˜¯ .pdf çš„é“¾æ¥
                  if (!pdfLinkEl) {
                     pdfLinkEl = document.querySelector('a[href$=".pdf"]');
                  }
                  
                  let pdfUrl = '';
                  if (pdfLinkEl) {
                    // è½¬ä¸ºç»å¯¹è·¯å¾„
                    pdfUrl = new URL(pdfLinkEl.href, window.location.href).href;
                  }

                  // 3. æŠ“å–æ—¥æœŸ
                  let date = '';
                  const matchDate = vm.route.file.match(/(\d{4}-\d{2}-\d{2})/);
                  if (matchDate) {
                    date = matchDate[1];
                  }
                  const citationDate = date ? date.replace(/-/g, '/') : '';

                  // 4. æŠ“å–ä½œè€…
                  let authors = [];
                  document.querySelectorAll('.markdown-section p').forEach(p => {
                    if (p.innerText.includes('Authors:')) {
                      const text = p.innerText.replace('Authors:', '').trim();
                      authors = text.split(/,|ï¼Œ/).map(a => a.trim());
                    }
                  });

                  // 5. å†™å…¥ Meta æ ‡ç­¾
                  console.log("Updating Zotero metadata for:", title);
                  updateMetaTag('citation_title', title);
                  updateMetaTag('citation_journal_title', 'Daily Paper Reader (ArXiv)'); // å¿…é¡»æœ‰è¿™ä¸ª
                  updateMetaTag('citation_pdf_url', pdfUrl, { useFallback: false });
                  updateMetaTag('citation_publication_date', date);
                  updateMetaTag('citation_date', citationDate);

                  document.querySelectorAll('meta[name="citation_author"]').forEach(el => el.remove());
                  const authorList = authors.length ? authors : defaultAuthors;
                  authorList.forEach(author => {
                    const meta = document.createElement('meta');
                    meta.name = 'citation_author';
                    meta.content = author;
                    document.head.appendChild(meta);
                  });

                  // 6. ã€å…³é”®ã€‘å‘é€ Zotero æ›´æ–°äº‹ä»¶
                  // å‘Šè¯‰æ’ä»¶é‡æ–°æ‰«æé¡µé¢
                  document.dispatchEvent(new Event('ZoteroItemUpdated', {
                      bubbles: true,
                      cancelable: true
                  }));

                } catch (e) {
                  console.error('Zotero meta update failed:', e);
                }
            }, 1); // å»¶è¿Ÿ 800ms æ‰§è¡Œï¼Œç­‰å¾… DOM æ¸²æŸ“å®Œæ¯•
          });
        }
      ]
    }
  </script>
  
  <!-- ä¾§è¾¹æ å®½åº¦æ‹–æ‹½è„šæœ¬ -->
  <script>
    (function() {
      function setupSidebarResizer() {
        if (window.innerWidth <= 768) return;
        if (document.getElementById('sidebar-resizer')) return;

        var resizer = document.createElement('div');
        resizer.id = 'sidebar-resizer';
        document.body.appendChild(resizer);

        var dragging = false;

        resizer.addEventListener('mousedown', function(e) {
          dragging = true;
          e.preventDefault();
        });

        window.addEventListener('mousemove', function(e) {
          if (!dragging) return;
          var styles = getComputedStyle(document.documentElement);
          var min = parseInt(styles.getPropertyValue('--sidebar-min-width')) || 180;
          var max = parseInt(styles.getPropertyValue('--sidebar-max-width')) || 480;
          var newWidth = e.clientX;
          if (newWidth < min) newWidth = min;
          if (newWidth > max) newWidth = max;
          document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
        });

        window.addEventListener('mouseup', function() {
          dragging = false;
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupSidebarResizer);
      } else {
        setupSidebarResizer();
      }

      window.addEventListener('resize', function() {
        var resizer = document.getElementById('sidebar-resizer');
        if (window.innerWidth <= 768) {
          if (resizer) resizer.style.display = 'none';
        } else {
          if (resizer) {
            resizer.style.display = 'block';
          } else {
            setupSidebarResizer();
          }
        }
      });
    })();
  </script>

  <script src="//cdn.jsdelivr.net/npm/docsify@4/lib/docsify.min.js"></script>
</body>
</html>
